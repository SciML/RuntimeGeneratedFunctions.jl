var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#RuntimeGeneratedFunctions.RuntimeGeneratedFunction","page":"API","title":"RuntimeGeneratedFunctions.RuntimeGeneratedFunction","text":"@RuntimeGeneratedFunction(function_expression)\n@RuntimeGeneratedFunction(context_module, function_expression, opaque_closures=true)\n\nRuntimeGeneratedFunction(cache_module, context_module, function_expression; opaque_closures=true)\n\nConstruct a function from function_expression which can be called immediately without world age problems. Somewhat like using eval(function_expression) and then calling the resulting function. The differences are:\n\nThe result can be called immediately (immune to world age errors)\nThe result is not a named generic function, and doesn't participate in generic function dispatch; it's more like a callable method.\n\nYou need to use RuntimeGeneratedFunctions.init(your_module) a single time at the top level of your_module before any other uses of the macro.\n\nIf provided, context_module is the module in which symbols within function_expression will be looked up. By default, this is the module in which @RuntimeGeneratedFunction is expanded.\n\ncache_module is the module where the expression code will be cached. If RuntimeGeneratedFunction is used during precompilation, this must be a module which is currently being precompiled. Normally this would be set to @__MODULE__ using one of the macro constructors.\n\nIf opaque_closures is true, all closures in function_expression are converted to opaque closures. This allows for the use of closures and generators inside the generated function, but may not work in all cases due to slightly different semantics.\n\nExamples\n\nRuntimeGeneratedFunctions.init(@__MODULE__) # Required at module top-level\n\nfunction foo()\n    expression = :((x,y)->x+y+1) # May be generated dynamically\n    f = @RuntimeGeneratedFunction(expression)\n    f(1,2) # May be called immediately\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#RuntimeGeneratedFunctions.init-Tuple{Any}","page":"API","title":"RuntimeGeneratedFunctions.init","text":"RuntimeGeneratedFunctions.init(mod)\n\nUse this at top level to set up your module mod before using @RuntimeGeneratedFunction.\n\n\n\n\n\n","category":"method"},{"location":"api/#RuntimeGeneratedFunctions.@RuntimeGeneratedFunction-Tuple{Any}","page":"API","title":"RuntimeGeneratedFunctions.@RuntimeGeneratedFunction","text":"@RuntimeGeneratedFunction(function_expression)\n@RuntimeGeneratedFunction(context_module, function_expression, opaque_closures=true)\n\nRuntimeGeneratedFunction(cache_module, context_module, function_expression; opaque_closures=true)\n\nConstruct a function from function_expression which can be called immediately without world age problems. Somewhat like using eval(function_expression) and then calling the resulting function. The differences are:\n\nThe result can be called immediately (immune to world age errors)\nThe result is not a named generic function, and doesn't participate in generic function dispatch; it's more like a callable method.\n\nYou need to use RuntimeGeneratedFunctions.init(your_module) a single time at the top level of your_module before any other uses of the macro.\n\nIf provided, context_module is the module in which symbols within function_expression will be looked up. By default, this is the module in which @RuntimeGeneratedFunction is expanded.\n\ncache_module is the module where the expression code will be cached. If RuntimeGeneratedFunction is used during precompilation, this must be a module which is currently being precompiled. Normally this would be set to @__MODULE__ using one of the macro constructors.\n\nIf opaque_closures is true, all closures in function_expression are converted to opaque closures. This allows for the use of closures and generators inside the generated function, but may not work in all cases due to slightly different semantics.\n\nExamples\n\nRuntimeGeneratedFunctions.init(@__MODULE__) # Required at module top-level\n\nfunction foo()\n    expression = :((x,y)->x+y+1) # May be generated dynamically\n    f = @RuntimeGeneratedFunction(expression)\n    f(1,2) # May be called immediately\nend\n\n\n\n\n\n","category":"macro"},{"location":"#RuntimeGeneratedFunctions.jl:-Generate-functions-at-runtime","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Generate functions at runtime","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"RuntimeGeneratedFunctions are functions generated at runtime without world-age issues and with the full performance of a standard Julia anonymous function. This builds functions in a way that avoids eval.","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"Note that RuntimeGeneratedFunction does not handle closures. Please use the GeneralizedGenerated.jl package for more fixable staged programming. While GeneralizedGenerated.jl is more powerful, RuntimeGeneratedFunctions.jl handles large expressions better.","category":"page"},{"location":"#Tutorials-and-Documentation","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Tutorials and Documentation","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"For information on using the package, see the stable documentation. Use the in-development documentation for the version of the documentation, which contains the unreleased features.","category":"page"},{"location":"#Simple-Example","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Simple Example","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"Here's an example showing how to construct and immediately call a runtime generated function:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(@__MODULE__)\n\nfunction no_worldage()\n    ex = :(function f(_du, _u, _p, _t)\n        @inbounds _du[1] = _u[1]\n        @inbounds _du[2] = _u[2]\n        nothing\n    end)\n    f1 = @RuntimeGeneratedFunction(ex)\n    du = rand(2)\n    u = rand(2)\n    p = nothing\n    t = nothing\n    f1(du, u, p, t)\nend\nno_worldage()","category":"page"},{"location":"#Changing-how-global-symbols-are-looked-up","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Changing how global symbols are looked up","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"If you want to use helper functions or global variables from a different module within your function expression, you'll need to pass a context_module to the @RuntimeGeneratedFunction constructor. For example","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"RuntimeGeneratedFunctions.init(@__MODULE__)\n\nmodule A\nusing RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(A)\nhelper_function(x) = x + 1\nend\n\nfunction g()\n    expression = :(f(x) = helper_function(x))\n    # context module is `A` so that `helper_function` can be found.\n    f = @RuntimeGeneratedFunction(A, expression)\n    @show f(1)\nend","category":"page"},{"location":"#Precompilation-and-setting-the-function-expression-cache","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Precompilation and setting the function expression cache","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"For technical reasons, RuntimeGeneratedFunctions needs to cache the function expression in a global variable within some module. This is normally transparent to the user, but if the RuntimeGeneratedFunction is evaluated during module precompilation, the cache module must be explicitly set to the module currently being precompiled. This is relevant for helper functions in some module, which construct a RuntimeGeneratedFunction on behalf of the user. For example, in the following code, any third party user of HelperModule.construct_rgf() user needs to pass their own module as the cache_module if they want the returned function to work after precompilation:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"RuntimeGeneratedFunctions.init(@__MODULE__)\n\n# Imagine HelperModule is in a separate package and will be precompiled\n# separately.\nmodule HelperModule\nusing RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(HelperModule)\n\nfunction construct_rgf(cache_module, context_module, ex)\n    ex = :((x) -> $ex^2 + x)\n    RuntimeGeneratedFunction(cache_module, context_module, ex)\nend\nend\n\nfunction g()\n    ex = :(x + 1)\n    # Here cache_module is set to the module currently being compiled so that\n    # the returned RGF works with Julia's module precompilation system.\n    HelperModule.construct_rgf(@__MODULE__, @__MODULE__, ex)\nend\n\nf = g()\n@show f(1)","category":"page"},{"location":"#Retrieving-Expressions","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Retrieving Expressions","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"From a constructed RuntimeGeneratedFunction, you can retrieve the expressions using the RuntimeGeneratedFunctions.get_expression command. For example:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"ex = :((x) -> x^2)\nrgf = @RuntimeGeneratedFunction(ex)\njulia> RuntimeGeneratedFunctions.get_expression(rgf)\n:((x,)->begin\n          #= REPL[14]:1 =#\n          x ^ 2\n      end)","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"This can be used to get the expression even if drop_expr has been performed.","category":"page"},{"location":"#Example:-Retrieving-Expressions-from-ModelingToolkit.jl","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Example: Retrieving Expressions from ModelingToolkit.jl","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"ModelingToolkit.jl uses RuntimeGeneratedFunctions.jl for the construction of its functions to avoid issues of world-age. Take for example its tutorial:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using ModelingToolkit, RuntimeGeneratedFunctions\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@mtkmodel FOL begin\n    @parameters begin\n        τ # parameters\n    end\n    @variables begin\n        x(t) # dependent variables\n    end\n    @equations begin\n        D(x) ~ (1 - x) / τ\n    end\nend\n\nusing DifferentialEquations: solve\n@mtkbuild fol = FOL()\nprob = ODEProblem(fol, [fol.x => 0.0], (0.0, 10.0), [fol.τ => 3.0])","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"If we check the function:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"julia> prob.f\n(::ODEFunction{true, SciMLBase.AutoSpecialize, ModelingToolkit.var\"#f#697\"{RuntimeGeneratedFunction{(:ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x2cce5cf2, 0xd20b0d73, 0xd14ed8a6, 0xa4d56c4f, 0x72958ea1), Nothing}, RuntimeGeneratedFunction{(:ˍ₋out, :ˍ₋arg1, :ˍ₋arg2, :t), ModelingToolkit.var\"#_RGF_ModTag\", ModelingToolkit.var\"#_RGF_ModTag\", (0x7f3c227e, 0x8f116bb1, 0xb3528ad5, 0x9c57c605, 0x60f580c3), Nothing}}, UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, ModelingToolkit.var\"#852#generated_observed#706\"{Bool, ODESystem, Dict{Any, Any}, Vector{Any}}, Nothing, ODESystem, Nothing, Nothing}) (generic function with 1 method)","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"It's a RuntimeGeneratedFunction. We can find the code for this system using the retrieval command on the function we want. For example, for the in-place function:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"julia> RuntimeGeneratedFunctions.get_expression(prob.f.f.f_iip)\n\n:((ˍ₋out, ˍ₋arg1, ˍ₋arg2, t)->begin\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:373 =#\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:374 =#\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:375 =#\n          begin\n              begin\n                  begin\n                      #= C:\\Users\\accou\\.julia\\packages\\Symbolics\\HIg7O\\src\\build_function.jl:546 =#\n                      #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:422 =# @inbounds begin\n                              #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:418 =#\n                              ˍ₋out[1] = (/)((+)(1, (*)(-1, ˍ₋arg1[1])), ˍ₋arg2[1])\n                              #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:420 =#\n                              nothing\n                          end\n                  end\n              end\n          end\n      end)","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"or the out-of-place function:","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"julia> RuntimeGeneratedFunctions.get_expression(prob.f.f.f_oop)\n:((ˍ₋arg1, ˍ₋arg2, t)->begin\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:373 =#\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:374 =#\n          #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:375 =#\n          begin\n              begin\n                  begin\n                      #= C:\\Users\\accou\\.julia\\packages\\SymbolicUtils\\c0xQb\\src\\code.jl:468 =#\n                      (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(1,)}(), (/)((+)(1, (*)(-1, ˍ₋arg1[1])), ˍ₋arg2[1]))\n                  end\n              end\n          end\n      end)","category":"page"},{"location":"#Reproducibility","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"</details>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"</details>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"</details>","category":"page"},{"location":"","page":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","title":"RuntimeGeneratedFunctions.jl: Efficient Staged Compilation","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
